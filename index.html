<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <title>CHRONOS Earth Control System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');

```
    :root {
        --neon-blue: #00FFFF !important;
        --neon-cyan: #25E1ED !important;
        --electric-blue: #0080FF !important;
        --temporal-gold: #C8B029 !important;
        --quantum-purple: #BD00FF !important;
        --deep-black: #00060e !important;
        --charcoal: #1A1A1A !important;
        --radiation-green: #00FF9F !important;
        --panel-bg: rgba(0, 6, 14, 0.95) !important;
        --glow-blue: 0 0 20px #00FFFF, 0 0 40px #25E1ED !important;
    }

    * {
        margin: 0 !important;
        padding: 0 !important;
        box-sizing: border-box !important;
    }

    body {
        background: radial-gradient(ellipse at center, #001122 0%, var(--deep-black) 70%) !important;
        font-family: 'Orbitron', monospace !important;
        overflow: hidden !important;
        position: fixed !important;
        width: 100% !important;
        height: 100% !important;
        color: var(--neon-blue) !important;
        cursor: none !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -webkit-touch-callout: none !important;
    }

    #globe-container {
        width: 100% !important;
        height: 100% !important;
        touch-action: pan-x pan-y !important;
        position: relative !important;
    }

    .loading-screen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        background: var(--deep-black) !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 1000 !important;
        transition: opacity 0.8s ease-out !important;
    }

    .loading-spinner {
        width: 80px !important;
        height: 80px !important;
        border: 3px solid transparent !important;
        border-top: 3px solid var(--neon-blue) !important;
        border-radius: 50% !important;
        animation: spin 1.5s linear infinite !important;
        margin-bottom: 2rem !important;
        box-shadow: var(--glow-blue) !important;
    }

    @keyframes spin {
        0% { transform: rotate(0deg) !important; }
        100% { transform: rotate(360deg) !important; }
    }

    .system-title {
        color: var(--neon-blue) !important;
        font-size: clamp(2rem, 6vw, 4rem) !important;
        font-weight: 900 !important;
        text-align: center !important;
        letter-spacing: 4px !important;
        text-shadow: var(--glow-blue) !important;
        animation: pulse-title 3s ease-in-out infinite !important;
        margin-bottom: 1rem !important;
    }

    @keyframes pulse-title {
        0%, 100% { 
            opacity: 1 !important; 
            text-shadow: var(--glow-blue) !important;
        }
        50% { 
            opacity: 0.7 !important; 
            text-shadow: 0 0 10px var(--neon-blue) !important;
        }
    }

    .loading-text {
        color: var(--neon-cyan) !important;
        font-size: 1.2rem !important;
        font-weight: 300 !important;
        text-align: center !important;
        animation: pulse 2s ease-in-out infinite !important;
    }

    .hud-container {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: none !important;
        z-index: 100 !important;
    }

    .top-hud {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        padding: 1rem !important;
        background: linear-gradient(to bottom, var(--panel-bg) 0%, transparent 100%) !important;
    }

    .chronos-header {
        text-align: center !important;
        margin-bottom: 1rem !important;
    }

    .main-title {
        color: var(--neon-blue) !important;
        font-size: clamp(1.8rem, 5vw, 3rem) !important;
        font-weight: 900 !important;
        letter-spacing: 3px !important;
        text-shadow: var(--glow-blue) !important;
        animation: glow-pulse 4s ease-in-out infinite !important;
    }

    @keyframes glow-pulse {
        0%, 100% { text-shadow: var(--glow-blue) !important; }
        50% { text-shadow: 0 0 30px var(--neon-blue), 0 0 60px var(--neon-cyan) !important; }
    }

    .subtitle {
        color: var(--neon-cyan) !important;
        font-size: 0.9rem !important;
        font-weight: 300 !important;
        letter-spacing: 1px !important;
        margin-top: 0.5rem !important;
    }

    .control-grid {
        display: grid !important;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)) !important;
        gap: 1rem !important;
        pointer-events: auto !important;
    }

    .control-panel {
        background: var(--panel-bg) !important;
        border: 1px solid var(--neon-blue) !important;
        border-radius: 8px !important;
        padding: 1rem !important;
        backdrop-filter: blur(10px) !important;
        box-shadow: 
            0 0 20px rgba(0, 255, 255, 0.2),
            inset 0 0 20px rgba(0, 255, 255, 0.05) !important;
        transition: all 0.3s ease !important;
    }

    .control-panel:active {
        border-color: var(--neon-cyan) !important;
        box-shadow: 
            0 0 30px rgba(37, 225, 237, 0.4),
            inset 0 0 30px rgba(37, 225, 237, 0.1) !important;
    }

    .panel-header {
        display: flex !important;
        align-items: center !important;
        margin-bottom: 0.8rem !important;
    }

    .status-dot {
        width: 10px !important;
        height: 10px !important;
        border-radius: 50% !important;
        background: var(--neon-blue) !important;
        box-shadow: 0 0 10px var(--neon-blue) !important;
        animation: pulse-dot 2s ease-in-out infinite !important;
        margin-right: 10px !important;
    }

    @keyframes pulse-dot {
        0%, 100% { opacity: 1 !important; transform: scale(1) !important; }
        50% { opacity: 0.6 !important; transform: scale(1.2) !important; }
    }

    .panel-title {
        color: var(--neon-cyan) !important;
        font-size: 0.9rem !important;
        font-weight: 600 !important;
        text-transform: uppercase !important;
        letter-spacing: 1px !important;
    }

    .panel-content {
        color: white !important;
    }

    .data-value {
        font-size: 1.4rem !important;
        font-weight: 700 !important;
        color: var(--neon-blue) !important;
        margin-bottom: 0.3rem !important;
    }

    .data-label {
        font-size: 0.8rem !important;
        color: rgba(255, 255, 255, 0.7) !important;
        font-weight: 300 !important;
    }

    .bottom-hud {
        position: absolute !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        padding: 1rem !important;
        background: linear-gradient(to top, var(--panel-bg) 0%, transparent 100%) !important;
        text-align: center !important;
    }

    .instructions {
        color: rgba(255, 255, 255, 0.8) !important;
        font-size: 0.9rem !important;
        font-weight: 300 !important;
        pointer-events: auto !important;
    }

    .tmz-tooltip {
        position: absolute !important;
        background: var(--panel-bg) !important;
        border: 1px solid var(--neon-blue) !important;
        border-radius: 6px !important;
        padding: 1rem !important;
        color: white !important;
        font-size: 0.9rem !important;
        box-shadow: var(--glow-blue) !important;
        backdrop-filter: blur(10px) !important;
        max-width: 300px !important;
        z-index: 200 !important;
        transform: translate(-50%, -100%) !important;
        pointer-events: none !important;
        opacity: 0 !important;
        transition: opacity 0.3s ease !important;
    }

    .tmz-tooltip.visible {
        opacity: 1 !important;
    }

    .tmz-tooltip h4 {
        color: var(--neon-cyan) !important;
        margin-bottom: 0.5rem !important;
        font-size: 1rem !important;
        font-weight: 700 !important;
    }

    .tmz-tooltip .tmz-info {
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }

    .tmz-tooltip .info-item {
        display: flex !important;
        flex-direction: column !important;
    }

    .tmz-tooltip .info-label {
        font-size: 0.7rem !important;
        color: rgba(255, 255, 255, 0.6) !important;
        text-transform: uppercase !important;
    }

    .tmz-tooltip .info-value {
        font-size: 0.9rem !important;
        color: var(--neon-blue) !important;
        font-weight: 600 !important;
    }

    .network-status {
        display: flex !important;
        align-items: center !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }

    .network-indicator {
        width: 6px !important;
        height: 6px !important;
        border-radius: 50% !important;
        background: var(--radiation-green) !important;
        box-shadow: 0 0 8px var(--radiation-green) !important;
        animation: pulse-network 1.5s ease-in-out infinite !important;
    }

    @keyframes pulse-network {
        0%, 100% { opacity: 1 !important; }
        50% { opacity: 0.4 !important; }
    }

    .custom-cursor {
        position: fixed !important;
        width: 20px !important;
        height: 20px !important;
        border: 2px solid var(--neon-blue) !important;
        border-radius: 50% !important;
        background: rgba(0, 255, 255, 0.1) !important;
        pointer-events: none !important;
        z-index: 9999 !important;
        transition: transform 0.1s ease !important;
        box-shadow: 0 0 10px var(--neon-blue) !important;
    }

    .scanner-line {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 2px !important;
        background: linear-gradient(90deg, transparent, var(--neon-blue), transparent) !important;
        animation: scanner 3s linear infinite !important;
        opacity: 0.6 !important;
    }

    @keyframes scanner {
        0% { top: 0 !important; opacity: 0 !important; }
        10% { opacity: 0.6 !important; }
        90% { opacity: 0.6 !important; }
        100% { top: 100% !important; opacity: 0 !important; }
    }

    /* Mobile-specific styles with !important */
    .control-grid {
        grid-template-columns: 1fr !important;
        gap: 0.8rem !important;
    }
    
    .control-panel {
        padding: 0.8rem !important;
    }
    
    .main-title {
        font-size: 2rem !important;
        letter-spacing: 2px !important;
    }
    
    .tmz-tooltip {
        max-width: 250px !important;
        font-size: 0.8rem !important;
    }
    
    .instructions {
        font-size: 0.8rem !important;
    }

    /* Fixed positioning for tooltip to prevent jitter */
    .tmz-info-panel {
        position: fixed !important;
        bottom: 120px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        background: var(--panel-bg) !important;
        border: 1px solid var(--neon-blue) !important;
        border-radius: 8px !important;
        padding: 1rem !important;
        max-width: 90% !important;
        z-index: 300 !important;
        backdrop-filter: blur(10px) !important;
        box-shadow: var(--glow-blue) !important;
        opacity: 0 !important;
        transition: opacity 0.3s ease !important;
        pointer-events: none !important;
    }

    .tmz-info-panel.visible {
        opacity: 1 !important;
    }

    @media (prefers-reduced-motion: reduce) {
        * {
            animation: none !important;
            transition: none !important;
        }
    }
</style>
```

</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner"></div>
        <h1 class="system-title">CHRONOS</h1>
        <p class="loading-text">Initializing Temporal Control Matrix...</p>
        <div style="margin-top: 2rem; font-size: 0.9rem; color: rgba(37, 225, 237, 0.7);">
            <div>▶ Loading TMZ Network...</div>
            <div>▶ Establishing Quantum Links...</div>
            <div>▶ Calibrating Reality Anchors...</div>
        </div>
    </div>

```
<div id="globe-container">
    <div class="scanner-line"></div>
</div>

<div class="hud-container">
    <div class="top-hud">
        <div class="chronos-header">
            <h1 class="main-title">CHRONOS</h1>
            <p class="subtitle">TEMPORAL METROPOLITAN ZONE CONTROL SYSTEM</p>
        </div>
        
        <div class="control-grid">
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">System Status</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="utc-time">--:--:--</div>
                    <div class="data-label">Universal Temporal Control</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);">ONLINE</span>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">Active TMZs</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="tmz-count">8</div>
                    <div class="data-label">Monitored Zones</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);" id="tmz-status">SYNCHRONIZED</span>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">Chrono-Rail Network</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="rail-connections">14</div>
                    <div class="data-label">Active Connections</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);">OPERATIONAL</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="bottom-hud">
        <div class="instructions">
            <span style="color: var(--neon-cyan);">◀ DRAG ▶</span> to rotate • 
            <span style="color: var(--neon-cyan);">⬉ PINCH ⬊</span> to zoom • 
            <span style="color: var(--neon-cyan);">▣ TAP</span> TMZs for detailed information
        </div>
    </div>
</div>

<div id="tmz-info-panel" class="tmz-info-panel">
    <h4 id="info-panel-title" style="color: var(--neon-cyan); margin-bottom: 0.5rem;">TMZ Information</h4>
    <p id="info-panel-description" style="margin-bottom: 0.8rem; color: rgba(255,255,255,0.8);"></p>
    <div class="tmz-info">
        <div class="info-item">
            <span class="info-label">Population</span>
            <span class="info-value" id="info-panel-population">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Status</span>
            <span class="info-value" id="info-panel-status">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Tier Level</span>
            <span class="info-value" id="info-panel-tier">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">UTC Offset</span>
            <span class="info-value" id="info-panel-offset">--</span>
        </div>
    </div>
</div>

<div class="custom-cursor" id="custom-cursor"></div>

<!-- Three.js with multiple fallbacks -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
        onerror="this.onerror=null;this.src='https://unpkg.com/three@0.150.0/build/three.min.js'"></script>

<!-- Hammer.js with fallback -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js" 
        onerror="this.onerror=null;this.src='https://unpkg.com/hammerjs@2.0.8/hammer.min.js'"></script>

<script>
    // CHRONOS Earth Control System v3.0 - Fixed Version
    class CHRONOSEarth {
        constructor() {
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.earth = null;
            this.atmosphere = null;
            this.tmzMarkers = [];
            this.railLines = [];
            this.selectedTMZ = null;
            this.isRotating = false;
            this.lastInteraction = Date.now();
            
            // CHRONOS TMZ Data based on lore
            this.tmzData = this.initializeTMZData();
            this.railConnections = this.initializeRailNetwork();
            
            this.setupCursor();
            this.waitForLibraries().then(() => {
                this.init();
            }).catch(error => {
                console.error('Libraries failed to load:', error);
                this.initFallback();
            });
        }

        initializeTMZData() {
            // Based on CHRONOS lore from knowledge files
            return [
                {
                    name: "Boston Prime",
                    lat: 42.3601, lng: -71.0589,
                    population: "4.7M", status: "ALPHA COMMAND", tier: "PRIME",
                    offset: "-05:00", 
                    description: "Primary CHRONOS Command Hub. Houses the Master Clock and central temporal control systems. Location of the Erasure Bureau headquarters."
                },
                {
                    name: "Neo London",
                    lat: 51.5074, lng: -0.1278,
                    population: "3.9M", status: "OPERATIONAL", tier: "ALPHA", 
                    offset: "+00:00",
                    description: "European Temporal Hub. Coordinates continental grid and manages reality anchor network across the European sector."
                },
                {
                    name: "New Tokyo",
                    lat: 35.6762, lng: 139.6503,
                    population: "6.2M", status: "OPERATIONAL", tier: "ALPHA",
                    offset: "+09:00",
                    description: "Pacific Command Center. Advanced quantum processing facilities and temporal weapon development labs."
                },
                {
                    name: "Sydney Nexus",
                    lat: -33.8688, lng: 151.2093,
                    population: "2.1M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+11:00",
                    description: "Oceanic Hub. Experimental temporal isolation chambers and reality stabilization research."
                },
                {
                    name: "Cairo Temporal",
                    lat: 30.0444, lng: 31.2357,
                    population: "1.8M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+02:00",
                    description: "African Command. Desert climate optimization and specialized quantum wasteland containment."
                },
                {
                    name: "São Paulo Grid",
                    lat: -23.5505, lng: -46.6333,
                    population: "2.8M", status: "OPERATIONAL", tier: "BETA",
                    offset: "-03:00",
                    description: "South American Hub. Advanced atmospheric temporal control and rainforest quantum zones."
                },
                {
                    name: "Delhi Quantum",
                    lat: 28.6139, lng: 77.2090,
                    population: "4.3M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+05:30",
                    description: "South Asian Center. High-density population temporal management and monsoon reality control."
                },
                {
                    name: "Siberian Outpost",
                    lat: 60.0, lng: 90.0,
                    population: "0.3M", status: "RESTRICTED", tier: "GAMMA",
                    offset: "+07:00",
                    description: "Classified research facility. Extreme climate temporal testing and deep quantum experiments."
                }
            ];
        }

        initializeRailNetwork() {
            // Major Chrono-Rail connections based on lore
            return [
                ["Boston Prime", "Neo London"],
                ["Neo London", "New Tokyo"],
                ["New Tokyo", "Boston Prime"],
                ["Sydney Nexus", "New Tokyo"],
                ["Neo London", "Cairo Temporal"],
                ["Cairo Temporal", "Delhi Quantum"],
                ["Delhi Quantum", "New Tokyo"],
                ["Boston Prime", "São Paulo Grid"],
                ["São Paulo Grid", "Neo London"],
                ["Sydney Nexus", "São Paulo Grid"],
                ["Siberian Outpost", "New Tokyo"],
                ["Siberian Outpost", "Neo London"],
                ["Delhi Quantum", "Cairo Temporal"],
                ["Boston Prime", "Siberian Outpost"]
            ];
        }

        setupCursor() {
            const cursor = document.getElementById('custom-cursor');
            document.addEventListener('mousemove', (e) => {
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';
            });

            document.addEventListener('mousedown', () => {
                cursor.style.transform = 'scale(0.8)';
            });

            document.addEventListener('mouseup', () => {
                cursor.style.transform = 'scale(1)';
            });
        }

        async waitForLibraries() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50;
                
                const checkLibraries = () => {
                    attempts++;
                    
                    if (typeof THREE !== 'undefined') {
                        resolve();
                        return;
                    }
                    
                    if (attempts >= maxAttempts) {
                        reject(new Error('Libraries failed to load'));
                        return;
                    }
                    
                    setTimeout(checkLibraries, 100);
                };
                
                checkLibraries();
            });
        }

        async init() {
            try {
                this.setupThreeJS();
                this.createCHRONOSEarth();
                this.addLighting();
                this.addTMZMarkers();
                this.addRailConnections();
                this.setupControls();
                this.startAnimation();
                this.startTimeUpdates();
                this.updateNetworkStats();
                
                setTimeout(() => {
                    this.hideLoading();
                }, 3000);
                
            } catch (error) {
                console.error('Failed to initialize CHRONOS Earth:', error);
                this.initFallback();
            }
        }

        setupThreeJS() {
            const container = document.getElementById('globe-container');
            
            // Scene setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x00060e);
            
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.z = 300;
            
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x00060e, 1);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(this.renderer.domElement);
        }

        createCHRONOSEarth() {
            // Create Earth geometry
            const geometry = new THREE.SphereGeometry(80, 64, 32);
            
            // Create custom CHRONOS texture - BLACK EARTH with BLUE CONTINENT LINES
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Deep black base for post-Quantum Wars Earth
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add darker landmass shapes
            ctx.fillStyle = '#1a1a1a';
            this.drawContinentMasses(ctx);
            
            // Add bright blue neon continent outlines
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 15;
            this.drawContinentOutlines(ctx);
            
            // Add TMZ zones
            this.drawTMZZones(ctx);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                transparent: false,
                shininess: 5,
                specular: 0x001122
            });
            
            this.earth = new THREE.Mesh(geometry, material);
            this.earth.castShadow = true;
            this.earth.receiveShadow = true;
            this.scene.add(this.earth);
            
            // Add blue atmospheric glow
            this.addAtmosphereGlow();
        }

        drawContinentMasses(ctx) {
            // Post-Quantum Wars continent shapes - altered by temporal warfare
            
            // North America (fractured and reshaped)
            ctx.beginPath();
            ctx.moveTo(280, 380);
            ctx.quadraticCurveTo(380, 330, 520, 380);
            ctx.quadraticCurveTo(580, 420, 620, 380);
            ctx.lineTo(640, 520);
            ctx.quadraticCurveTo(520, 570, 380, 520);
            ctx.quadraticCurveTo(320, 500, 280, 520);
            ctx.closePath();
            ctx.fill();
            
            // Europe/Africa (merged by tectonic shifts)
            ctx.beginPath();
            ctx.moveTo(920, 320);
            ctx.quadraticCurveTo(1080, 280, 1220, 320);
            ctx.lineTo(1280, 650);
            ctx.quadraticCurveTo(1180, 680, 1080, 650);
            ctx.quadraticCurveTo(980, 670, 920, 650);
            ctx.closePath();
            ctx.fill();
            
            // Asia (expanded eastward)
            ctx.beginPath();
            ctx.moveTo(1300, 280);
            ctx.quadraticCurveTo(1520, 240, 1720, 280);
            ctx.quadraticCurveTo(1780, 380, 1720, 520);
            ctx.quadraticCurveTo(1620, 540, 1520, 520);
            ctx.quadraticCurveTo(1350, 500, 1300, 480);
            ctx.closePath();
            ctx.fill();
            
            // Australia/Oceania (new island formations)
            ctx.beginPath();
            ctx.moveTo(1580, 720);
            ctx.quadraticCurveTo(1720, 700, 1820, 720);
            ctx.quadraticCurveTo(1840, 780, 1820, 820);
            ctx.quadraticCurveTo(1720, 840, 1580, 820);
            ctx.closePath();
            ctx.fill();
            
            // South America (shifted northward)
            ctx.beginPath();
            ctx.moveTo(600, 580);
            ctx.quadraticCurveTo(720, 560, 800, 600);
            ctx.lineTo(780, 900);
            ctx.quadraticCurveTo(720, 920, 640, 900);
            ctx.quadraticCurveTo(580, 880, 600, 820);
            ctx.closePath();
            ctx.fill();
        }

        drawContinentOutlines(ctx) {
            // Bright neon blue outlines for continent borders
            
            // North America outline
            ctx.beginPath();
            ctx.moveTo(280, 380);
            ctx.quadraticCurveTo(380, 330, 520, 380);
            ctx.quadraticCurveTo(580, 420, 620, 380);
            ctx.lineTo(640, 520);
            ctx.quadraticCurveTo(520, 570, 380, 520);
            ctx.quadraticCurveTo(320, 500, 280, 520);
            ctx.closePath();
            ctx.stroke();
            
            // Europe/Africa outline
            ctx.beginPath();
            ctx.moveTo(920, 320);
            ctx.quadraticCurveTo(1080, 280, 1220, 320);
            ctx.lineTo(1280, 650);
            ctx.quadraticCurveTo(1180, 680, 1080, 650);
            ctx.quadraticCurveTo(980, 670, 920, 650);
            ctx.closePath();
            ctx.stroke();
            
            // Asia outline
            ctx.beginPath();
            ctx.moveTo(1300, 280);
            ctx.quadraticCurveTo(1520, 240, 1720, 280);
            ctx.quadraticCurveTo(1780, 380, 1720, 520);
            ctx.quadraticCurveTo(1620, 540, 1520, 520);
            ctx.quadraticCurveTo(1350, 500, 1300, 480);
            ctx.closePath();
            ctx.stroke();
            
            // Australia/Oceania outline
            ctx.beginPath();
            ctx.moveTo(1580, 720);
            ctx.quadraticCurveTo(1720, 700, 1820, 720);
            ctx.quadraticCurveTo(1840, 780, 1820, 820);
            ctx.quadraticCurveTo(1720, 840, 1580, 820);
            ctx.closePath();
            ctx.stroke();
            
            // South America outline
            ctx.beginPath();
            ctx.moveTo(600, 580);
            ctx.quadraticCurveTo(720, 560, 800, 600);
            ctx.lineTo(780, 900);
            ctx.quadraticCurveTo(720, 920, 640, 900);
            ctx.quadraticCurveTo(580, 880, 600, 820);
            ctx.closePath();
            ctx.stroke();
        }

        drawTMZZones(ctx) {
            // Draw TMZ zones based on lore data
            ctx.strokeStyle = '#25E1ED';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#25E1ED';
            ctx.shadowBlur = 20;
            
            this.tmzData.forEach(tmz => {
                const x = ((tmz.lng + 180) / 360) * 2048;
                const y = ((90 - tmz.lat) / 180) * 1024;
                const radius = tmz.tier === 'PRIME' ? 100 : tmz.tier === 'ALPHA' ? 80 : 60;
                
                // Draw TMZ boundary circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Add glowing center dot
                ctx.fillStyle = tmz.tier === 'PRIME' ? '#FFD700' : '#00FFFF';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        addAtmosphereGlow() {
            const glowGeometry = new THREE.SphereGeometry(85, 32, 16);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 2.0) * 0.1 + 0.9;
                        gl_FragColor = vec4(0.0, 1.0, 1.0, intensity * 0.2 * pulse);
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            
            this.atmosphere = new THREE.Mesh(glowGeometry, glowMaterial);
            this.scene.add(this.atmosphere);
        }

        addLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x00FFFF, 0.7);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            this.scene.add(directionalLight);
            
            // Add rim lighting
            const rimLight = new THREE.DirectionalLight(0x25E1ED, 0.3);
            rimLight.position.set(-1, 0, -1);
            this.scene.add(rimLight);
        }

        addTMZMarkers() {
            this.tmzMarkers = [];
            
            this.tmzData.forEach((tmz, index) => {
                const position = this.latLonToVector3(tmz.lat, tmz.lng, 82);
                
                // Create different marker types based on tier
                let markerGeometry, markerMaterial;
                
                if (tmz.tier === 'PRIME') {
                    markerGeometry = new THREE.ConeGeometry(2, 12, 8);
                    markerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.9
                    });
                } else if (tmz.tier === 'ALPHA') {
                    markerGeometry = new THREE.CylinderGeometry(1.5, 3, 10, 8);
                    markerMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.9
                    });
                } else {
                    markerGeometry = new THREE.SphereGeometry(2, 8, 6);
                    markerMaterial = new THREE.MeshBasicMaterial({
                        color: 0x25E1ED,
                        transparent: true,
                        opacity: 0.8
                    });
                }
                
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(position);
                marker.lookAt(new THREE.Vector3(0, 0, 0));
                marker.userData = { tmz: tmz, index: index };
                marker.name = `tmz-${index}`;
                
                this.scene.add(marker);
                this.tmzMarkers.push(marker);
            });
        }

        addRailConnections() {
            this.railLines = [];
            
            this.railConnections.forEach(connection => {
                const tmz1 = this.tmzData.find(t => t.name === connection[0]);
                const tmz2 = this.tmzData.find(t => t.name === connection[1]);
                
                if (tmz1 && tmz2) {
                    this.createRailConnection(tmz1, tmz2);
                }
            });
        }

        createRailConnection(tmz1, tmz2) {
            const start = this.latLonToVector3(tmz1.lat, tmz1.lng, 81);
            const end = this.latLonToVector3(tmz2.lat, tmz2.lng, 81);
            
            // Create curved path that follows Earth's surface
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mid.normalize().multiplyScalar(95); // Curve outward from Earth surface
            
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            
            const line = new THREE.Line(geometry, material);
            this.scene.add(line);
            this.railLines.push(line);
        }

        setupControls() {
            const canvas = this.renderer.domElement;
            
            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotationVelocity = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                this.isRotating = false;
                this.lastInteraction = Date.now();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                rotationVelocity.x = deltaMove.y * 0.01;
                rotationVelocity.y = deltaMove.x * 0.01;
                
                this.earth.rotation.x += rotationVelocity.x;
                this.earth.rotation.y += rotationVelocity.y;
                this.atmosphere.rotation.x += rotationVelocity.x * 0.5;
                this.atmosphere.rotation.y += rotationVelocity.y * 0.5;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                setTimeout(() => {
                    this.isRotating = true;
                }, 2000);
            });

            canvas.addEventListener('click', (e) => {
                this.handleClick(e);
            });
            
            // Touch controls
            if (typeof Hammer !== 'undefined') {
                const hammer = new Hammer(canvas);
                hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
                hammer.get('pinch').set({ enable: true });
                
                hammer.on('panstart', () => {
                    this.isRotating = false;
                    this.lastInteraction = Date.now();
                });
                
                hammer.on('pan', (event) => {
                    const sensitivity = 0.005;
                    this.earth.rotation.x += event.deltaY * sensitivity;
                    this.earth.rotation.y += event.deltaX * sensitivity;
                    this.atmosphere.rotation.x += event.deltaY * sensitivity * 0.5;
                    this.atmosphere.rotation.y += event.deltaX * sensitivity * 0.5;
                });
                
                hammer.on('panend', () => {
                    setTimeout(() => {
                        this.isRotating = true;
                    }, 2000);
                });

                hammer.on('tap', (event) => {
                    this.handleClick(event.srcEvent);
                });
                
                hammer.on('pinch', (event) => {
                    const scale = event.scale;
                    this.camera.position.z = Math.max(150, Math.min(500, this.camera.position.z / scale));
                });
            }
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 10;
                this.camera.position.z += e.deltaY * zoomSpeed * 0.01;
                this.camera.position.z = Math.max(150, Math.min(500, this.camera.position.z));
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Auto-rotation setup
            this.isRotating = true;
        }

        handleClick(event) {
            const rect = this.renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, this.camera);
            
            const intersects = raycaster.intersectObjects(this.tmzMarkers);
            
            if (intersects.length > 0) {
                const tmz = intersects[0].object.userData.tmz;
                this.showTMZInfo(tmz);
            } else {
                this.hideTMZInfo();
            }
        }

        showTMZInfo(tmz) {
            this.selectedTMZ = tmz;
            const infoPanel = document.getElementById('tmz-info-panel');
            
            document.getElementById('info-panel-title').textContent = tmz.name;
            document.getElementById('info-panel-description').textContent = tmz.description;
            document.getElementById('info-panel-population').textContent = tmz.population;
            document.getElementById('info-panel-status').textContent = tmz.status;
            document.getElementById('info-panel-tier').textContent = tmz.tier;
            document.getElementById('info-panel-offset').textContent = tmz.offset;
            
            infoPanel.classList.add('visible');
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                this.hideTMZInfo();
            }, 8000);
        }

        hideTMZInfo() {
            const infoPanel = document.getElementById('tmz-info-panel');
            infoPanel.classList.remove('visible');
            this.selectedTMZ = null;
        }

        startAnimation() {
            const animate = () => {
                requestAnimationFrame(animate);
                
                const time = Date.now() * 0.001;
                
                // Auto-rotation when not interacting
                if (this.isRotating && Date.now() - this.lastInteraction > 3000) {
                    this.earth.rotation.y += 0.002;
                    this.atmosphere.rotation.y += 0.001;
                }
                
                // Update atmosphere shader
                if (this.atmosphere && this.atmosphere.material.uniforms) {
                    this.atmosphere.material.uniforms.time.value = time;
                }
                
                // Animate TMZ markers
                this.tmzMarkers.forEach((marker, index) => {
                    const pulseSpeed = 0.003;
                    const phase = index * 0.5;
                    marker.material.opacity = 0.7 + 0.3 * Math.sin(time * pulseSpeed + phase);
                });
                
                // Animate rail connections
                this.railLines.forEach((line, index) => {
                    const pulseSpeed = 0.004;
                    const phase = index * 0.3;
                    line.material.opacity = 0.5 + 0.3 * Math.sin(time * pulseSpeed + phase);
                });
                
                this.renderer.render(this.scene, this.camera);
            };
            
            animate();
        }

        startTimeUpdates() {
            const updateTime = () => {
                const now = new Date();
                const utcTime = now.toUTCString().split(' ')[4];
                document.getElementById('utc-time').textContent = utcTime;
            };

            updateTime();
            setInterval(updateTime, 1000);
        }

        updateNetworkStats() {
            document.getElementById('tmz-count').textContent = this.tmzData.length;
            document.getElementById('rail-connections').textContent = this.railConnections.length;
        }

        latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            return new THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        hideLoading() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 800);
        }

        initFallback() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.innerHTML = `
                <div style="text-align: center;">
                    <h2 style="color: #ff4444; margin-bottom: 1rem;">CHRONOS SYSTEM ERROR</h2>
                    <p style="color: #ffaa44; margin-bottom: 1rem;">Failed to initialize 3D Earth system</p>
                    <p style="color: #ffffff; font-size: 0.9rem;">Please check your internet connection and refresh the page</p>
                    <button onclick="location.reload()" style="
                        margin-top: 1rem;
                        padding: 0.8rem 1.5rem;
                        background: #00FFFF;
                        color: #00060e;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-family: 'Orbitron', monospace;
                        font-weight: 700;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                    ">RETRY INITIALIZATION</button>
                </div>
            `;
        }
    }

    // Initialize CHRONOS Earth Control System
    document.addEventListener('DOMContentLoaded', () => {
        new CHRONOSEarth();
    });

    // Prevent zoom on double tap for mobile
    document.addEventListener('touchstart', function(event) {
        if (event.touches.length > 1) {
            event.preventDefault();
        }
    });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
</script>
```

</body>
</html>
