<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <title>CHRONOS Earth Control System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&display=swap');

```
    :root {
        --neon-blue: #00FFFF !important;
        --neon-cyan: #25E1ED !important;
        --electric-blue: #0080FF !important;
        --temporal-gold: #C8B029 !important;
        --quantum-purple: #BD00FF !important;
        --deep-black: #00060e !important;
        --charcoal: #1A1A1A !important;
        --radiation-green: #00FF9F !important;
        --panel-bg: rgba(0, 6, 14, 0.95) !important;
        --glow-blue: 0 0 20px #00FFFF, 0 0 40px #25E1ED !important;
    }

    * {
        margin: 0 !important;
        padding: 0 !important;
        box-sizing: border-box !important;
    }

    body {
        background: radial-gradient(ellipse at center, #001122 0%, var(--deep-black) 70%) !important;
        font-family: 'Orbitron', monospace !important;
        overflow: hidden !important;
        position: fixed !important;
        width: 100% !important;
        height: 100% !important;
        color: var(--neon-blue) !important;
        cursor: none !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -webkit-touch-callout: none !important;
    }

    #globe-container {
        width: 100% !important;
        height: 100% !important;
        touch-action: pan-x pan-y !important;
        position: relative !important;
    }

    .loading-screen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        background: var(--deep-black) !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 1000 !important;
        transition: opacity 0.8s ease-out !important;
    }

    .loading-spinner {
        width: 80px !important;
        height: 80px !important;
        border: 3px solid transparent !important;
        border-top: 3px solid var(--neon-blue) !important;
        border-radius: 50% !important;
        animation: spin 1.5s linear infinite !important;
        margin-bottom: 2rem !important;
        box-shadow: var(--glow-blue) !important;
    }

    @keyframes spin {
        0% { transform: rotate(0deg) !important; }
        100% { transform: rotate(360deg) !important; }
    }

    .system-title {
        color: var(--neon-blue) !important;
        font-size: clamp(2rem, 6vw, 4rem) !important;
        font-weight: 900 !important;
        text-align: center !important;
        letter-spacing: 4px !important;
        text-shadow: var(--glow-blue) !important;
        animation: pulse-title 3s ease-in-out infinite !important;
        margin-bottom: 1rem !important;
    }

    @keyframes pulse-title {
        0%, 100% { 
            opacity: 1 !important; 
            text-shadow: var(--glow-blue) !important;
        }
        50% { 
            opacity: 0.7 !important; 
            text-shadow: 0 0 10px var(--neon-blue) !important;
        }
    }

    .loading-text {
        color: var(--neon-cyan) !important;
        font-size: 1.2rem !important;
        font-weight: 300 !important;
        text-align: center !important;
        animation: pulse 2s ease-in-out infinite !important;
    }

    .hud-container {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: none !important;
        z-index: 100 !important;
    }

    .top-hud {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        padding: 1rem !important;
        background: linear-gradient(to bottom, var(--panel-bg) 0%, transparent 100%) !important;
    }

    .chronos-header {
        text-align: center !important;
        margin-bottom: 1rem !important;
    }

    .main-title {
        color: var(--neon-blue) !important;
        font-size: clamp(1.8rem, 5vw, 3rem) !important;
        font-weight: 900 !important;
        letter-spacing: 3px !important;
        text-shadow: var(--glow-blue) !important;
        animation: glow-pulse 4s ease-in-out infinite !important;
    }

    @keyframes glow-pulse {
        0%, 100% { text-shadow: var(--glow-blue) !important; }
        50% { text-shadow: 0 0 30px var(--neon-blue), 0 0 60px var(--neon-cyan) !important; }
    }

    .subtitle {
        color: var(--neon-cyan) !important;
        font-size: 0.9rem !important;
        font-weight: 300 !important;
        letter-spacing: 1px !important;
        margin-top: 0.5rem !important;
    }

    .control-grid {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 0.8rem !important;
        pointer-events: auto !important;
    }

    .control-panel {
        background: var(--panel-bg) !important;
        border: 1px solid var(--neon-blue) !important;
        border-radius: 8px !important;
        padding: 0.8rem !important;
        backdrop-filter: blur(10px) !important;
        box-shadow: 
            0 0 20px rgba(0, 255, 255, 0.2),
            inset 0 0 20px rgba(0, 255, 255, 0.05) !important;
        transition: all 0.3s ease !important;
    }

    .control-panel:active {
        border-color: var(--neon-cyan) !important;
        box-shadow: 
            0 0 30px rgba(37, 225, 237, 0.4),
            inset 0 0 30px rgba(37, 225, 237, 0.1) !important;
    }

    .panel-header {
        display: flex !important;
        align-items: center !important;
        margin-bottom: 0.8rem !important;
    }

    .status-dot {
        width: 10px !important;
        height: 10px !important;
        border-radius: 50% !important;
        background: var(--neon-blue) !important;
        box-shadow: 0 0 10px var(--neon-blue) !important;
        animation: pulse-dot 2s ease-in-out infinite !important;
        margin-right: 10px !important;
    }

    @keyframes pulse-dot {
        0%, 100% { opacity: 1 !important; transform: scale(1) !important; }
        50% { opacity: 0.6 !important; transform: scale(1.2) !important; }
    }

    .panel-title {
        color: var(--neon-cyan) !important;
        font-size: 0.9rem !important;
        font-weight: 600 !important;
        text-transform: uppercase !important;
        letter-spacing: 1px !important;
    }

    .panel-content {
        color: white !important;
    }

    .data-value {
        font-size: 1.4rem !important;
        font-weight: 700 !important;
        color: var(--neon-blue) !important;
        margin-bottom: 0.3rem !important;
    }

    .data-label {
        font-size: 0.8rem !important;
        color: rgba(255, 255, 255, 0.7) !important;
        font-weight: 300 !important;
    }

    .bottom-hud {
        position: absolute !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        padding: 1rem !important;
        background: linear-gradient(to top, var(--panel-bg) 0%, transparent 100%) !important;
        text-align: center !important;
    }

    .instructions {
        color: rgba(255, 255, 255, 0.8) !important;
        font-size: 0.8rem !important;
        font-weight: 300 !important;
        pointer-events: auto !important;
    }

    .tmz-info-panel {
        position: fixed !important;
        bottom: 120px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        background: var(--panel-bg) !important;
        border: 1px solid var(--neon-blue) !important;
        border-radius: 8px !important;
        padding: 1rem !important;
        max-width: 90% !important;
        z-index: 300 !important;
        backdrop-filter: blur(10px) !important;
        box-shadow: var(--glow-blue) !important;
        opacity: 0 !important;
        transition: opacity 0.3s ease !important;
        pointer-events: none !important;
    }

    .tmz-info-panel.visible {
        opacity: 1 !important;
    }

    .tmz-info-panel h4 {
        color: var(--neon-cyan) !important;
        margin-bottom: 0.5rem !important;
        font-size: 1rem !important;
        font-weight: 700 !important;
    }

    .tmz-info {
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }

    .info-item {
        display: flex !important;
        flex-direction: column !important;
    }

    .info-label {
        font-size: 0.7rem !important;
        color: rgba(255, 255, 255, 0.6) !important;
        text-transform: uppercase !important;
    }

    .info-value {
        font-size: 0.9rem !important;
        color: var(--neon-blue) !important;
        font-weight: 600 !important;
    }

    .network-status {
        display: flex !important;
        align-items: center !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }

    .network-indicator {
        width: 6px !important;
        height: 6px !important;
        border-radius: 50% !important;
        background: var(--radiation-green) !important;
        box-shadow: 0 0 8px var(--radiation-green) !important;
        animation: pulse-network 1.5s ease-in-out infinite !important;
    }

    @keyframes pulse-network {
        0%, 100% { opacity: 1 !important; }
        50% { opacity: 0.4 !important; }
    }

    .custom-cursor {
        position: fixed !important;
        width: 20px !important;
        height: 20px !important;
        border: 2px solid var(--neon-blue) !important;
        border-radius: 50% !important;
        background: rgba(0, 255, 255, 0.1) !important;
        pointer-events: none !important;
        z-index: 9999 !important;
        transition: transform 0.1s ease !important;
        box-shadow: 0 0 10px var(--neon-blue) !important;
    }

    .scanner-line {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 2px !important;
        background: linear-gradient(90deg, transparent, var(--neon-blue), transparent) !important;
        animation: scanner 3s linear infinite !important;
        opacity: 0.6 !important;
    }

    @keyframes scanner {
        0% { top: 0 !important; opacity: 0 !important; }
        10% { opacity: 0.6 !important; }
        90% { opacity: 0.6 !important; }
        100% { top: 100% !important; opacity: 0 !important; }
    }

    .debug-info {
        position: fixed !important;
        top: 10px !important;
        right: 10px !important;
        background: rgba(0, 0, 0, 0.8) !important;
        color: #00FFFF !important;
        padding: 10px !important;
        border-radius: 5px !important;
        font-size: 0.8rem !important;
        z-index: 1000 !important;
        display: none !important;
    }

    .debug-info.show {
        display: block !important;
    }

    @media (prefers-reduced-motion: reduce) {
        * {
            animation: none !important;
            transition: none !important;
        }
    }
</style>
```

</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner"></div>
        <h1 class="system-title">CHRONOS</h1>
        <p class="loading-text">Initializing Temporal Control Matrix...</p>
        <div style="margin-top: 2rem; font-size: 0.9rem; color: rgba(37, 225, 237, 0.7);">
            <div id="loading-step1">▶ Loading Three.js Core...</div>
            <div id="loading-step2">▶ Establishing TMZ Network...</div>
            <div id="loading-step3">▶ Calibrating Reality Anchors...</div>
        </div>
    </div>

```
<div id="globe-container">
    <div class="scanner-line"></div>
</div>

<div class="hud-container">
    <div class="top-hud">
        <div class="chronos-header">
            <h1 class="main-title">CHRONOS</h1>
            <p class="subtitle">TEMPORAL METROPOLITAN ZONE CONTROL SYSTEM</p>
        </div>
        
        <div class="control-grid">
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">System Status</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="utc-time">--:--:--</div>
                    <div class="data-label">Universal Temporal Control</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);" id="system-status">INITIALIZING</span>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">Active TMZs</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="tmz-count">8</div>
                    <div class="data-label">Monitored Zones</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);" id="tmz-status">SYNCHRONIZED</span>
                    </div>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="panel-header">
                    <div class="status-dot"></div>
                    <h3 class="panel-title">Chrono-Rail Network</h3>
                </div>
                <div class="panel-content">
                    <div class="data-value" id="rail-connections">14</div>
                    <div class="data-label">Active Connections</div>
                    <div class="network-status">
                        <div class="network-indicator"></div>
                        <span style="font-size: 0.8rem; color: var(--radiation-green);" id="rail-status">OPERATIONAL</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="bottom-hud">
        <div class="instructions">
            <span style="color: var(--neon-cyan);">◀ DRAG ▶</span> to rotate • 
            <span style="color: var(--neon-cyan);">⬉ PINCH ⬊</span> to zoom • 
            <span style="color: var(--neon-cyan);">▣ TAP</span> TMZs for detailed information
        </div>
    </div>
</div>

<div id="tmz-info-panel" class="tmz-info-panel">
    <h4 id="info-panel-title">TMZ Information</h4>
    <p id="info-panel-description" style="margin-bottom: 0.8rem; color: rgba(255,255,255,0.8);"></p>
    <div class="tmz-info">
        <div class="info-item">
            <span class="info-label">Population</span>
            <span class="info-value" id="info-panel-population">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Status</span>
            <span class="info-value" id="info-panel-status">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">Tier Level</span>
            <span class="info-value" id="info-panel-tier">--</span>
        </div>
        <div class="info-item">
            <span class="info-label">UTC Offset</span>
            <span class="info-value" id="info-panel-offset">--</span>
        </div>
    </div>
</div>

<div class="custom-cursor" id="custom-cursor"></div>

<div id="debug-info" class="debug-info">
    <div>THREE.js: <span id="debug-threejs">Loading...</span></div>
    <div>WebGL: <span id="debug-webgl">Checking...</span></div>
    <div>Mobile: <span id="debug-mobile">Detecting...</span></div>
    <div>Performance: <span id="debug-perf">--</span></div>
</div>

<!-- Use jsDelivr CDN with fallback - Most reliable for GitHub Pages -->
<script type="module">
    // Performance monitoring and debugging
    const DEBUG = window.location.hostname === 'localhost' || window.location.search.includes('debug=1');
    let startTime = performance.now();
    
    function updateDebug(key, value) {
        const element = document.getElementById(`debug-${key}`);
        if (element) element.textContent = value;
        if (DEBUG) {
            console.log(`Debug ${key}:`, value);
            document.getElementById('debug-info').classList.add('show');
        }
    }

    // Initialize debug info
    updateDebug('mobile', /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? 'Yes' : 'No');
    updateDebug('webgl', !!window.WebGLRenderingContext ? 'Supported' : 'Not Supported');

    async function loadThreeJS() {
        try {
            document.getElementById('loading-step1').style.color = '#25E1ED';
            
            // Primary CDN: jsDelivr (most reliable for GitHub Pages)
            const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js');
            window.THREE = THREE;
            updateDebug('threejs', 'Loaded (jsDelivr)');
            return THREE;
        } catch (error) {
            console.warn('Primary CDN failed, trying fallback:', error);
            try {
                // Fallback CDN: unpkg
                const THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
                window.THREE = THREE;
                updateDebug('threejs', 'Loaded (unpkg)');
                return THREE;
            } catch (fallbackError) {
                console.error('All CDNs failed:', fallbackError);
                updateDebug('threejs', 'Failed');
                throw new Error('Failed to load Three.js from all CDNs');
            }
        }
    }

    // CHRONOS Earth Control System - GitHub Pages Optimized
    class CHRONOSEarth {
        constructor() {
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.earth = null;
            this.atmosphere = null;
            this.tmzMarkers = [];
            this.railLines = [];
            this.selectedTMZ = null;
            this.isRotating = false;
            this.lastInteraction = Date.now();
            this.isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            // Performance optimization for mobile
            this.pixelRatio = this.isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
            this.particleCount = this.isMobile ? 1000 : 5000;
            this.enableShadows = !this.isMobile;
            
            // CHRONOS TMZ Data based on lore
            this.tmzData = this.initializeTMZData();
            this.railConnections = this.initializeRailNetwork();
            
            this.setupCursor();
            this.init();
        }

        initializeTMZData() {
            // Based on CHRONOS lore from knowledge files
            return [
                {
                    name: "Boston Prime",
                    lat: 42.3601, lng: -71.0589,
                    population: "4.7M", status: "ALPHA COMMAND", tier: "PRIME",
                    offset: "-05:00", 
                    description: "Primary CHRONOS Command Hub. Houses the Master Clock and central temporal control systems. Location of the Erasure Bureau headquarters."
                },
                {
                    name: "Neo London",
                    lat: 51.5074, lng: -0.1278,
                    population: "3.9M", status: "OPERATIONAL", tier: "ALPHA", 
                    offset: "+00:00",
                    description: "European Temporal Hub. Coordinates continental grid and manages reality anchor network across the European sector."
                },
                {
                    name: "New Tokyo",
                    lat: 35.6762, lng: 139.6503,
                    population: "6.2M", status: "OPERATIONAL", tier: "ALPHA",
                    offset: "+09:00",
                    description: "Pacific Command Center. Advanced quantum processing facilities and temporal weapon development labs."
                },
                {
                    name: "Sydney Nexus",
                    lat: -33.8688, lng: 151.2093,
                    population: "2.1M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+11:00",
                    description: "Oceanic Hub. Experimental temporal isolation chambers and reality stabilization research."
                },
                {
                    name: "Cairo Temporal",
                    lat: 30.0444, lng: 31.2357,
                    population: "1.8M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+02:00",
                    description: "African Command. Desert climate optimization and specialized quantum wasteland containment."
                },
                {
                    name: "São Paulo Grid",
                    lat: -23.5505, lng: -46.6333,
                    population: "2.8M", status: "OPERATIONAL", tier: "BETA",
                    offset: "-03:00",
                    description: "South American Hub. Advanced atmospheric temporal control and rainforest quantum zones."
                },
                {
                    name: "Delhi Quantum",
                    lat: 28.6139, lng: 77.2090,
                    population: "4.3M", status: "OPERATIONAL", tier: "BETA",
                    offset: "+05:30",
                    description: "South Asian Center. High-density population temporal management and monsoon reality control."
                },
                {
                    name: "Siberian Outpost",
                    lat: 60.0, lng: 90.0,
                    population: "0.3M", status: "RESTRICTED", tier: "GAMMA",
                    offset: "+07:00",
                    description: "Classified research facility. Extreme climate temporal testing and deep quantum experiments."
                }
            ];
        }

        initializeRailNetwork() {
            // Major Chrono-Rail connections based on lore
            return [
                ["Boston Prime", "Neo London"],
                ["Neo London", "New Tokyo"],
                ["New Tokyo", "Boston Prime"],
                ["Sydney Nexus", "New Tokyo"],
                ["Neo London", "Cairo Temporal"],
                ["Cairo Temporal", "Delhi Quantum"],
                ["Delhi Quantum", "New Tokyo"],
                ["Boston Prime", "São Paulo Grid"],
                ["São Paulo Grid", "Neo London"],
                ["Sydney Nexus", "São Paulo Grid"],
                ["Siberian Outpost", "New Tokyo"],
                ["Siberian Outpost", "Neo London"],
                ["Delhi Quantum", "Cairo Temporal"],
                ["Boston Prime", "Siberian Outpost"]
            ];
        }

        setupCursor() {
            const cursor = document.getElementById('custom-cursor');
            document.addEventListener('mousemove', (e) => {
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';
            });

            document.addEventListener('mousedown', () => {
                cursor.style.transform = 'scale(0.8)';
            });

            document.addEventListener('mouseup', () => {
                cursor.style.transform = 'scale(1)';
            });
        }

        async init() {
            try {
                // Load Three.js with proper error handling
                const THREE = await loadThreeJS();
                
                document.getElementById('loading-step2').style.color = '#25E1ED';
                
                this.setupThreeJS();
                this.createCHRONOSEarth();
                this.addLighting();
                this.addTMZMarkers();
                this.addRailConnections();
                this.setupControls();
                this.startAnimation();
                this.startTimeUpdates();
                this.updateNetworkStats();
                
                document.getElementById('loading-step3').style.color = '#25E1ED';
                document.getElementById('system-status').textContent = 'ONLINE';
                
                // Performance monitoring
                const loadTime = performance.now() - startTime;
                updateDebug('perf', `${loadTime.toFixed(0)}ms`);
                
                setTimeout(() => {
                    this.hideLoading();
                }, 2000);
                
            } catch (error) {
                console.error('Failed to initialize CHRONOS Earth:', error);
                this.initFallback();
            }
        }

        setupThreeJS() {
            const container = document.getElementById('globe-container');
            
            // Scene setup
            this.scene = new window.THREE.Scene();
            this.scene.background = new window.THREE.Color(0x00060e);
            
            this.camera = new window.THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.z = this.isMobile ? 250 : 300;
            
            this.renderer = new window.THREE.WebGLRenderer({ 
                antialias: !this.isMobile, // Disable antialiasing on mobile for performance
                alpha: true,
                powerPreference: "high-performance"
            });
            this.renderer.setPixelRatio(this.pixelRatio);
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x00060e, 1);
            
            if (this.enableShadows) {
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;
            }
            
            container.appendChild(this.renderer.domElement);
        }

        createCHRONOSEarth() {
            // Create Earth geometry with appropriate detail for device
            const geometry = new window.THREE.SphereGeometry(80, this.isMobile ? 32 : 64, this.isMobile ? 16 : 32);
            
            // Create custom CHRONOS texture - BLACK EARTH with BLUE CONTINENT LINES
            const canvas = document.createElement('canvas');
            canvas.width = this.isMobile ? 1024 : 2048;
            canvas.height = this.isMobile ? 512 : 1024;
            const ctx = canvas.getContext('2d');
            
            // Deep black base for post-Quantum Wars Earth
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add darker landmass shapes
            ctx.fillStyle = '#1a1a1a';
            this.drawContinentMasses(ctx, canvas.width, canvas.height);
            
            // Add bright blue neon continent outlines
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = this.isMobile ? 2 : 4;
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = this.isMobile ? 8 : 15;
            this.drawContinentOutlines(ctx, canvas.width, canvas.height);
            
            // Add TMZ zones
            this.drawTMZZones(ctx, canvas.width, canvas.height);
            
            const texture = new window.THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new window.THREE.MeshPhongMaterial({
                map: texture,
                transparent: false,
                shininess: 5,
                specular: 0x001122
            });
            
            this.earth = new window.THREE.Mesh(geometry, material);
            if (this.enableShadows) {
                this.earth.castShadow = true;
                this.earth.receiveShadow = true;
            }
            this.scene.add(this.earth);
            
            // Add blue atmospheric glow
            this.addAtmosphereGlow();
        }

        drawContinentMasses(ctx, width, height) {
            const scale = width / 2048; // Scale based on actual canvas size
            
            // Post-Quantum Wars continent shapes - altered by temporal warfare
            
            // North America (fractured and reshaped)
            ctx.beginPath();
            ctx.moveTo(280 * scale, 380 * scale);
            ctx.quadraticCurveTo(380 * scale, 330 * scale, 520 * scale, 380 * scale);
            ctx.quadraticCurveTo(580 * scale, 420 * scale, 620 * scale, 380 * scale);
            ctx.lineTo(640 * scale, 520 * scale);
            ctx.quadraticCurveTo(520 * scale, 570 * scale, 380 * scale, 520 * scale);
            ctx.quadraticCurveTo(320 * scale, 500 * scale, 280 * scale, 520 * scale);
            ctx.closePath();
            ctx.fill();
            
            // Europe/Africa (merged by tectonic shifts)
            ctx.beginPath();
            ctx.moveTo(920 * scale, 320 * scale);
            ctx.quadraticCurveTo(1080 * scale, 280 * scale, 1220 * scale, 320 * scale);
            ctx.lineTo(1280 * scale, 650 * scale);
            ctx.quadraticCurveTo(1180 * scale, 680 * scale, 1080 * scale, 650 * scale);
            ctx.quadraticCurveTo(980 * scale, 670 * scale, 920 * scale, 650 * scale);
            ctx.closePath();
            ctx.fill();
            
            // Asia (expanded eastward)
            ctx.beginPath();
            ctx.moveTo(1300 * scale, 280 * scale);
            ctx.quadraticCurveTo(1520 * scale, 240 * scale, 1720 * scale, 280 * scale);
            ctx.quadraticCurveTo(1780 * scale, 380 * scale, 1720 * scale, 520 * scale);
            ctx.quadraticCurveTo(1620 * scale, 540 * scale, 1520 * scale, 520 * scale);
            ctx.quadraticCurveTo(1350 * scale, 500 * scale, 1300 * scale, 480 * scale);
            ctx.closePath();
            ctx.fill();
            
            // Australia/Oceania (new island formations)
            ctx.beginPath();
            ctx.moveTo(1580 * scale, 720 * scale);
            ctx.quadraticCurveTo(1720 * scale, 700 * scale, 1820 * scale, 720 * scale);
            ctx.quadraticCurveTo(1840 * scale, 780 * scale, 1820 * scale, 820 * scale);
            ctx.quadraticCurveTo(1720 * scale, 840 * scale, 1580 * scale, 820 * scale);
            ctx.closePath();
            ctx.fill();
            
            // South America (shifted northward)
            ctx.beginPath();
            ctx.moveTo(600 * scale, 580 * scale);
            ctx.quadraticCurveTo(720 * scale, 560 * scale, 800 * scale, 600 * scale);
            ctx.lineTo(780 * scale, 900 * scale);
            ctx.quadraticCurveTo(720 * scale, 920 * scale, 640 * scale, 900 * scale);
            ctx.quadraticCurveTo(580 * scale, 880 * scale, 600 * scale, 820 * scale);
            ctx.closePath();
            ctx.fill();
        }

        drawContinentOutlines(ctx, width, height) {
            const scale = width / 2048;
            
            // Bright neon blue outlines for continent borders
            
            // North America outline
            ctx.beginPath();
            ctx.moveTo(280 * scale, 380 * scale);
            ctx.quadraticCurveTo(380 * scale, 330 * scale, 520 * scale, 380 * scale);
            ctx.quadraticCurveTo(580 * scale, 420 * scale, 620 * scale, 380 * scale);
            ctx.lineTo(640 * scale, 520 * scale);
            ctx.quadraticCurveTo(520 * scale, 570 * scale, 380 * scale, 520 * scale);
            ctx.quadraticCurveTo(320 * scale, 500 * scale, 280 * scale, 520 * scale);
            ctx.closePath();
            ctx.stroke();
            
            // Europe/Africa outline
            ctx.beginPath();
            ctx.moveTo(920 * scale, 320 * scale);
            ctx.quadraticCurveTo(1080 * scale, 280 * scale, 1220 * scale, 320 * scale);
            ctx.lineTo(1280 * scale, 650 * scale);
            ctx.quadraticCurveTo(1180 * scale, 680 * scale, 1080 * scale, 650 * scale);
            ctx.quadraticCurveTo(980 * scale, 670 * scale, 920 * scale, 650 * scale);
            ctx.closePath();
            ctx.stroke();
            
            // Asia outline
            ctx.beginPath();
            ctx.moveTo(1300 * scale, 280 * scale);
            ctx.quadraticCurveTo(1520 * scale, 240 * scale, 1720 * scale, 280 * scale);
            ctx.quadraticCurveTo(1780 * scale, 380 * scale, 1720 * scale, 520 * scale);
            ctx.quadraticCurveTo(1620 * scale, 540 * scale, 1520 * scale, 520 * scale);
            ctx.quadraticCurveTo(1350 * scale, 500 * scale, 1300 * scale, 480 * scale);
            ctx.closePath();
            ctx.stroke();
            
            // Australia/Oceania outline
            ctx.beginPath();
            ctx.moveTo(1580 * scale, 720 * scale);
            ctx.quadraticCurveTo(1720 * scale, 700 * scale, 1820 * scale, 720 * scale);
            ctx.quadraticCurveTo(1840 * scale, 780 * scale, 1820 * scale, 820 * scale);
            ctx.quadraticCurveTo(1720 * scale, 840 * scale, 1580 * scale, 820 * scale);
            ctx.closePath();
            ctx.stroke();
            
            // South America outline
            ctx.beginPath();
            ctx.moveTo(600 * scale, 580 * scale);
            ctx.quadraticCurveTo(720 * scale, 560 * scale, 800 * scale, 600 * scale);
            ctx.lineTo(780 * scale, 900 * scale);
            ctx.quadraticCurveTo(720 * scale, 920 * scale, 640 * scale, 900 * scale);
            ctx.quadraticCurveTo(580 * scale, 880 * scale, 600 * scale, 820 * scale);
            ctx.closePath();
            ctx.stroke();
        }

        drawTMZZones(ctx, width, height) {
            // Draw TMZ zones based on lore data
            ctx.strokeStyle = '#25E1ED';
            ctx.lineWidth = this.isMobile ? 2 : 3;
            ctx.shadowColor = '#25E1ED';
            ctx.shadowBlur = this.isMobile ? 10 : 20;
            
            this.tmzData.forEach(tmz => {
                const x = ((tmz.lng + 180) / 360) * width;
                const y = ((90 - tmz.lat) / 180) * height;
                const radius = (tmz.tier === 'PRIME' ? 100 : tmz.tier === 'ALPHA' ? 80 : 60) * (width / 2048);
                
                // Draw TMZ boundary circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Add glowing center dot
                ctx.fillStyle = tmz.tier === 'PRIME' ? '#FFD700' : '#00FFFF';
                ctx.beginPath();
                ctx.arc(x, y, 8 * (width / 2048), 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        addAtmosphereGlow() {
            const glowGeometry = new window.THREE.SphereGeometry(85, this.isMobile ? 16 : 32, this.isMobile ? 8 : 16);
            const glowMaterial = new window.THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 2.0) * 0.1 + 0.9;
                        gl_FragColor = vec4(0.0, 1.0, 1.0, intensity * 0.2 * pulse);
                    }
                `,
                blending: window.THREE.AdditiveBlending,
                side: window.THREE.BackSide,
                transparent: true
            });
            
            this.atmosphere = new window.THREE.Mesh(glowGeometry, glowMaterial);
            this.scene.add(this.atmosphere);
        }

        addLighting() {
            const ambientLight = new window.THREE.AmbientLight(0x404040, 0.3);
            this.scene.add(ambientLight);
            
            const directionalLight = new window.THREE.DirectionalLight(0x00FFFF, 0.7);
            directionalLight.position.set(1, 1, 1);
            if (this.enableShadows) {
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = this.isMobile ? 1024 : 2048;
                directionalLight.shadow.mapSize.height = this.isMobile ? 1024 : 2048;
            }
            this.scene.add(directionalLight);
            
            // Add rim lighting
            const rimLight = new window.THREE.DirectionalLight(0x25E1ED, 0.3);
            rimLight.position.set(-1, 0, -1);
            this.scene.add(rimLight);
        }

        addTMZMarkers() {
            this.tmzMarkers = [];
            
            this.tmzData.forEach((tmz, index) => {
                const position = this.latLonToVector3(tmz.lat, tmz.lng, 82);
                
                // Create different marker types based on tier
                let markerGeometry, markerMaterial;
                
                if (tmz.tier === 'PRIME') {
                    markerGeometry = new window.THREE.ConeGeometry(2, 12, 8);
                    markerMaterial = new window.THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.9
                    });
                } else if (tmz.tier === 'ALPHA') {
                    markerGeometry = new window.THREE.CylinderGeometry(1.5, 3, 10, 8);
                    markerMaterial = new window.THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.9
                    });
                } else {
                    markerGeometry = new window.THREE.SphereGeometry(2, 8, 6);
                    markerMaterial = new window.THREE.MeshBasicMaterial({
                        color: 0x25E1ED,
                        transparent: true,
                        opacity: 0.8
                    });
                }
                
                const marker = new window.THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(position);
                marker.lookAt(new window.THREE.Vector3(0, 0, 0));
                marker.userData = { tmz: tmz, index: index };
                marker.name = `tmz-${index}`;
                
                this.scene.add(marker);
                this.tmzMarkers.push(marker);
            });
        }

        addRailConnections() {
            this.railLines = [];
            
            this.railConnections.forEach(connection => {
                const tmz1 = this.tmzData.find(t => t.name === connection[0]);
                const tmz2 = this.tmzData.find(t => t.name === connection[1]);
                
                if (tmz1 && tmz2) {
                    this.createRailConnection(tmz1, tmz2);
                }
            });
        }

        createRailConnection(tmz1, tmz2) {
            const start = this.latLonToVector3(tmz1.lat, tmz1.lng, 81);
            const end = this.latLonToVector3(tmz2.lat, tmz2.lng, 81);
            
            // Create curved path that follows Earth's surface
            const mid = new window.THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mid.normalize().multiplyScalar(95); // Curve outward from Earth surface
            
            const curve = new window.THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(this.isMobile ? 50 : 100);
            const geometry = new window.THREE.BufferGeometry().setFromPoints(points);
            
            const material = new window.THREE.LineBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            
            const line = new window.THREE.Line(geometry, material);
            this.scene.add(line);
            this.railLines.push(line);
        }

        setupControls() {
            const canvas = this.renderer.domElement;
            
            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                this.isRotating = false;
                this.lastInteraction = Date.now();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                const rotationSpeed = this.isMobile ? 0.005 : 0.01;
                this.earth.rotation.x += deltaMove.y * rotationSpeed;
                this.earth.rotation.y += deltaMove.x * rotationSpeed;
                this.atmosphere.rotation.x += deltaMove.y * rotationSpeed * 0.5;
                this.atmosphere.rotation.y += deltaMove.x * rotationSpeed * 0.5;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                setTimeout(() => {
                    this.isRotating = true;
                }, 2000);
            });

            canvas.addEventListener('click', (e) => {
                this.handleClick(e);
            });
            
            // Enhanced touch controls for mobile
            let touchStartPos = { x: 0, y: 0 };
            let touchStartTime = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.isRotating = false;
                this.lastInteraction = Date.now();
                
                const touch = e.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                touchStartTime = Date.now();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartPos.x;
                    const deltaY = touch.clientY - touchStartPos.y;
                    
                    const sensitivity = 0.003;
                    this.earth.rotation.x += deltaY * sensitivity;
                    this.earth.rotation.y += deltaX * sensitivity;
                    this.atmosphere.rotation.x += deltaY * sensitivity * 0.5;
                    this.atmosphere.rotation.y += deltaX * sensitivity * 0.5;
                    
                    touchStartPos = { x: touch.clientX, y: touch.clientY };
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                // Handle tap vs drag
                const touchDuration = Date.now() - touchStartTime;
                const touch = e.changedTouches[0];
                const deltaX = Math.abs(touch.clientX - touchStartPos.x);
                const deltaY = Math.abs(touch.clientY - touchStartPos.y);
                
                if (touchDuration < 300 && deltaX < 10 && deltaY < 10) {
                    // This was a tap, not a drag
                    this.handleClick(e.changedTouches[0]);
                }
                
                setTimeout(() => {
                    this.isRotating = true;
                }, 2000);
            }, { passive: false });
            
            // Pinch to zoom
            let initialDistance = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scale = distance / initialDistance;
                    
                    this.camera.position.z = Math.max(150, Math.min(500, this.camera.position.z / scale));
                    initialDistance = distance;
                }
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = this.isMobile ? 5 : 10;
                this.camera.position.z += e.deltaY * zoomSpeed * 0.01;
                this.camera.position.z = Math.max(150, Math.min(500, this.camera.position.z));
            }, { passive: false });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Auto-rotation setup
            this.isRotating = true;
        }

        handleClick(event) {
            const rect = this.renderer.domElement.getBoundingClientRect();
            const mouse = new window.THREE.Vector2();
            
            // Handle both mouse and touch events
            const clientX = event.clientX || event.targetTouches?.[0]?.clientX || event.changedTouches?.[0]?.clientX;
            const clientY = event.clientY || event.targetTouches?.[0]?.clientY || event.changedTouches?.[0]?.clientY;
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new window.THREE.Raycaster();
            raycaster.setFromCamera(mouse, this.camera);
            
            const intersects = raycaster.intersectObjects(this.tmzMarkers);
            
            if (intersects.length > 0) {
                const tmz = intersects[0].object.userData.tmz;
                this.showTMZInfo(tmz);
            } else {
                this.hideTMZInfo();
            }
        }

        showTMZInfo(tmz) {
            this.selectedTMZ = tmz;
            const infoPanel = document.getElementById('tmz-info-panel');
            
            document.getElementById('info-panel-title').textContent = tmz.name;
            document.getElementById('info-panel-description').textContent = tmz.description;
            document.getElementById('info-panel-population').textContent = tmz.population;
            document.getElementById('info-panel-status').textContent = tmz.status;
            document.getElementById('info-panel-tier').textContent = tmz.tier;
            document.getElementById('info-panel-offset').textContent = tmz.offset;
            
            infoPanel.classList.add('visible');
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                this.hideTMZInfo();
            }, 8000);
        }

        hideTMZInfo() {
            const infoPanel = document.getElementById('tmz-info-panel');
            infoPanel.classList.remove('visible');
            this.selectedTMZ = null;
        }

        startAnimation() {
            const animate = () => {
                requestAnimationFrame(animate);
                
                const time = Date.now() * 0.001;
                
                // Auto-rotation when not interacting
                if (this.isRotating && Date.now() - this.lastInteraction > 3000) {
                    this.earth.rotation.y += this.isMobile ? 0.001 : 0.002;
                    this.atmosphere.rotation.y += this.isMobile ? 0.0005 : 0.001;
                }
                
                // Update atmosphere shader
                if (this.atmosphere && this.atmosphere.material.uniforms) {
                    this.atmosphere.material.uniforms.time.value = time;
                }
                
                // Animate TMZ markers with reduced frequency on mobile
                const pulseSpeed = this.isMobile ? 0.002 : 0.003;
                this.tmzMarkers.forEach((marker, index) => {
                    const phase = index * 0.5;
                    marker.material.opacity = 0.7 + 0.3 * Math.sin(time * pulseSpeed + phase);
                });
                
                // Animate rail connections
                const railPulseSpeed = this.isMobile ? 0.002 : 0.004;
                this.railLines.forEach((line, index) => {
                    const phase = index * 0.3;
                    line.material.opacity = 0.5 + 0.3 * Math.sin(time * railPulseSpeed + phase);
                });
                
                this.renderer.render(this.scene, this.camera);
            };
            
            animate();
        }

        startTimeUpdates() {
            const updateTime = () => {
                const now = new Date();
                const utcTime = now.toUTCString().split(' ')[4];
                document.getElementById('utc-time').textContent = utcTime;
            };

            updateTime();
            setInterval(updateTime, 1000);
        }

        updateNetworkStats() {
            document.getElementById('tmz-count').textContent = this.tmzData.length;
            document.getElementById('rail-connections').textContent = this.railConnections.length;
        }

        latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            return new window.THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        hideLoading() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 800);
        }

        initFallback() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.innerHTML = `
                <div style="text-align: center;">
                    <h2 style="color: #ff4444; margin-bottom: 1rem;">CHRONOS SYSTEM ERROR</h2>
                    <p style="color: #ffaa44; margin-bottom: 1rem;">Failed to initialize 3D Earth system</p>
                    <p style="color: #ffffff; font-size: 0.9rem;">Three.js loading failed. Check console for details.</p>
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <p style="font-size: 0.8rem; color: #aaaaaa;">Debug Info:</p>
                        <p style="font-size: 0.8rem;">WebGL: ${!!window.WebGLRenderingContext}</p>
                        <p style="font-size: 0.8rem;">Mobile: ${/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)}</p>
                        <p style="font-size: 0.8rem;">URL: ${window.location.href}</p>
                    </div>
                    <button onclick="location.reload()" style="
                        margin-top: 1rem;
                        padding: 0.8rem 1.5rem;
                        background: #00FFFF;
                        color: #00060e;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-family: 'Orbitron', monospace;
                        font-weight: 700;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                    ">RETRY INITIALIZATION</button>
                </div>
            `;
            document.getElementById('system-status').textContent = 'ERROR';
            updateDebug('threejs', 'FAILED');
        }
    }

    // Initialize CHRONOS Earth Control System
    document.addEventListener('DOMContentLoaded', () => {
        new CHRONOSEarth();
    });

    // Prevent zoom on double tap for mobile
    document.addEventListener('touchstart', function(event) {
        if (event.touches.length > 1) {
            event.preventDefault();
        }
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });
</script>
```

</body>
</html>
